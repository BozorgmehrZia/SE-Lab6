# SE-Lab6
## مستندات آزمایش 6 مهندسی نرم افزار

### فاز اول
در ابتدا برای الگوی State به اینگونه عمل میکنیم که یک اینترفیس EdgeState تعریف کرده و سپس Directional بودن و نبودن یال ها را با آن تعریف میکنیم. برای اینترفیس مدنظر دو تابع میگذاریم که یکی جهتدار بودن یا نبودن را نشان بدهد و دیگری اینکه جهت را تغییر دهد. به این صورت:
![image](https://github.com/user-attachments/assets/d1d2c703-1776-4024-b1e9-e3dfee34367e)

حال در هر استیت تعریف میکنیم که چگونه جهت هارار تغییر دهد:(منظور این است که در استیت جهتدار بودن، همه یالهارا جهت دار کند.)
![image](https://github.com/user-attachments/assets/5e3a137d-b2ba-4381-af6a-e17cb76e25d4)

حال برای الگوی Strategy به این گونه عمل میکنیم که ما transport را به عنوان استراتژی در نظر گرفته و برای آن دو حالت اتوبوس و قطار را درنظر میگیریم و  اینترفیس TransportStrategy را بدین صورت درنظر میگیریم:
![image](https://github.com/user-attachments/assets/aa7f1410-b6e0-4565-a672-0539d3f845e5)

 و تابع مربوطه را در هرکدام از استراتژی ها با توجه به خواسته مساله پیاده سازی میکنیم:(برای این کار در ابتدا در کلاس گراف توابع مربوط به محاسبه فاصله ها را تغییر میدهیم. یک متغیر hated اضافه میکنیم که هروقت  null باشد یعنی ما شهر مورد نفرت نداریم)
 ![image](https://github.com/user-attachments/assets/93a712d9-a236-4f06-9ab5-eec4887f660d)

 ![image](https://github.com/user-attachments/assets/1440c80d-7a6e-41f5-93e4-ca276b5c834e)

و در نهایت تابعی به گراف اضافه میکنیم تا به ما نشان دهد چه استراتژی ای به صرفه تر است:
![image](https://github.com/user-attachments/assets/f5585c16-a604-4ed6-ab8b-40ada930ce2b)

در نهایت تست هایی برای پروژه مینویسیم وآنها را ران میکنیم و در نهایت میبینیم که به درستی همگی پاس میشوند.(ما گراف، استراتژی و استیت را بصورت جداگانه تست کردیم و همانطور که در تصویر مشاهده میشود همگی به درستی پاس شده اند.)

![image](https://github.com/user-attachments/assets/063a5057-322e-4d07-b0da-64f4cfc2c8e9)




### فاز دوم

#### دو مورد اعمال الگوی Facade

- یک کلاس FacadeParser ایجاد شده که یک رابط برای کلاس هایی است که بخواهند از کلاس  Parser استفاده کنند. این کلاس کار با پارسر را برای کلاس های بیرونی آسان می کند زیرا در صورتی که پیاده سازی کلاس Parser عوض شود این کلاس بدون تغییر خواهند ماند، از این رو FacadeParser پیچیدگی کار با پارسر را به شدت پایین آورده و احتمال خطاهای ممکن را پایین می آورد.

![image](https://github.com/user-attachments/assets/9098f31f-975b-480d-8a42-cdcaa0b56677)

![image](https://github.com/user-attachments/assets/3e07b76c-cbcc-4147-943e-e7b7ecdc9c51)

- یک کلاس FacadeToken ایجاد شده که یک رابط برای کلاس هایی است که بخواهند از کلاس  Token استفاده کنند. این کلاس نیز مزایایی که در بخش قبل توضیح داده شد دارد. همچنین باید کلاس LexicalAnalyzer را مطابق با کلاس جدید تغییر کند.
![image](https://github.com/user-attachments/assets/50350643-2bcf-4e7b-a1ae-99c18cb426d0)

![image](https://github.com/user-attachments/assets/1cbd3fed-44ba-4d3c-ab6f-cbc3e50d68b8)

#### یک مورد State/Strategy یا استفاده از Polymorphism به جای شرط

برای استفاده از پلی‌مورفیسم (Polymorphism) به جای شرط‌ها در کد، باید ابتدا شرایطی را شناسایی کنیم که می‌توانند با استفاده از زیرکلاس‌ها یا رابط‌ها (interfaces) جایگزین شوند. هدف این است که به جای استفاده از ساختارهای شرطی مانند if-else یا switch، رفتارهای مختلف را در کلاس‌های مختلف پیاده‌سازی کنیم که همه یک رابط یا کلاس پایه (superclass) مشترک را پیاده‌سازی می‌کنند.

به دنبال شرایطی میگردیم که رفتار یک متد بر اساس نوع Type تغییر می‌کند. در این حالت می‌توان به جای استفاده از شرط، از کلاس‌های جداگانه که از یک کلاس پایه یا رابط مشترک ارث‌بری کرده‌اند، استفاده کرد.
به عنوان مثال، در کلاس Token متد equals به صورت زیر بررسی می‌کند که آیا نوع Type برابر است یا خیر.در اینجا رفتار کلاس بسته به اینکه Type برابر با KEYWORDS باشد یا نه تغییر می‌کند.
می‌توانیم یک رابط یا کلاس پایه به نام AbstractToken ایجاد کنیم که رفتار عمومی Tokenها را تعریف کند و سپس برای هر نوع Type یک کلاس خاص بسازیم:

![image](https://github.com/user-attachments/assets/c50b32bc-bc88-4055-bb68-4af75f350719)

![image](https://github.com/user-attachments/assets/a650341e-764f-4f7c-9144-523536cde199)

![image](https://github.com/user-attachments/assets/2822690e-51e6-447c-abad-b109edf21cfa)

#### یک مورد Separate Query From Modifier

در کلاس ErrorHandler  باید متدی که هم وظیفه‌ی تغییر وضعیت (modifier) و هم وظیفه‌ی بازگشت مقدار (query) را بر عهده دارد، به دو متد جداگانه تقسیم کنیم. در این حالت، ما می‌خواهیم متد printError را بازآرایی کنیم به طوری که مسئولیت تغییر وضعیت و نمایش خطا به دو متد مجزا تقسیم شود.

![image](https://github.com/user-attachments/assets/fab00051-2bf3-4797-9045-1e7153de643d)

![image](https://github.com/user-attachments/assets/7ddeb5a1-dedc-42cb-9b3f-177a095bc4df)

#### یک مورد Self Encapsulated Field

برای پیاده‌سازی بازآرایی Self Encapsulated Field، شما باید به جای دسترسی مستقیم به یک فیلد، از متدهای getter و setter برای دسترسی و تغییر مقدار آن فیلد استفاده کنید. این بازآرایی معمولاً برای افزایش انعطاف‌پذیری و کنترل بیشتر بر نحوه‌ی دسترسی به فیلدهای کلاس انجام می‌شود.

![image](https://github.com/user-attachments/assets/bf4fee34-94c6-4b93-bd8f-9ffbc4da4cd0)

#### دو مورد مختلف غیر از بازآرایی‌های مطرح‌شده در موارد بالا

- در متد defMethod و برخی از متدهای دیگر، مقادیر مختلفی از symbolStack پاپ می‌شوند که هر کدام به یک کلاس یا متد خاص اشاره دارند. برای افزایش خوانایی و کاهش احتمال اشتباه، می‌توان این مقادیر را به متغیرهای موقتی با نام‌های توضیح‌دهنده تخصیص داد.

![image](https://github.com/user-attachments/assets/9905ec9f-aceb-4bc4-89e0-cba109579911)

![image](https://github.com/user-attachments/assets/ad631b95-3b89-4820-8a93-7f2a8fb5b93b)

- متد semanticFunction تعداد زیادی شرط switch-case دارد که منجر به پیچیدگی و عدم تمرکز در کد می‌شود. می‌توان این متد را به یک کلاس اختصاصی انتقال داد که هر شرط به متد خاص خود اختصاص داده شود. این باعث می‌شود تا هم کد منظم‌تر شود و هم قابلیت توسعه و نگهداری آن افزایش یابد.
ابتدا یک کلاس جدید با نام SemanticFunctionHandler ایجاد کنید و هر یک از کیس‌های switch را به یک متد در این کلاس منتقل کنید.

![image](https://github.com/user-attachments/assets/2097a3c3-6c8d-49a3-bff2-7f12ba2d65e0)

![image](https://github.com/user-attachments/assets/8b690e38-056c-4d25-a90a-9662dc4bbc3a)

![image](https://github.com/user-attachments/assets/b0571eb7-055b-4f0b-bfc8-3611bee9b9eb)








### پاسخ سوالات:

1.
- الگوهای طراحی سازنده (Creational Design Patterns): این الگوها الگوهای طراحی هستند که با مکانیسم های ایجاد اشیا سروکار دارند و سعی می کنند اشیا را به شیوه ای متناسب با موقعیت ایجاد کنند. شکل اصلی ایجاد شی می تواند منجر به مشکلات طراحی یا افزودن پیچیدگی به طراحی شود. الگوهای طراحی سازنده این مشکل را با کنترل ایجاد این شیء حل می کنند.
- الگوهای طراحی ساختاری (Structural Design Patterns): این نوع الگو طرحی است از نحوه ترکیب اشیاء و کلاس‌های مختلف برای تشکیل ساختار بزرگ‌تری برای دستیابی به اهداف متعدد. این الگوها نشان می‌دهند که چگونه قطعات منحصربه‌فرد یک سیستم را می‌توان به شکلی قابل توسعه و انعطاف‌پذیر با هم ترکیب کرد. بنابراین، با کمک این الگوها می‌توانیم بخش‌های خاصی از ساختار را بدون تغییر کل ساختار مورد هدف قرار داده و تغییر دهیم.
- الگوهای طراحی رفتاری (Behavioral Design Patterns): این دسته، الگوهای ارتباطی مشترک بین اشیاء را شناسایی کرده و این الگوها را تحقق می بخشند. با انجام این کار، این الگوها انعطاف پذیری را در انجام این ارتباط افزایش می دهند.

2.الگوهای طراحی رفتاری

3.
برای پاسخ دادن به سوال کاربران در این سیستم اطلاع‌رسانی، بهترین الگوی طراحی که می‌توان استفاده کرد، الگوی "State" است. در این سیستم، وضعیت یا حالت (State) مسیرها می‌تواند به صورت یک‌طرفه یا دوطرفه باشد. الگوی State به شما اجازه می‌دهد که رفتار یک سیستم را بر اساس وضعیت فعلی آن تغییر دهید، بدون نیاز به تغییر ساختار کلاس‌ها یا منطق داخلی آن.

چرا الگوی State مناسب است؟
- تغییر حالت پویا: در سیستم مورد نظر، مسیرها ممکن است بین حالت‌های یک‌طرفه و دوطرفه تغییر کنند. الگوی State امکان تغییر دینامیک وضعیت سیستم را به راحتی فراهم می‌کند.
- ساده‌سازی منطق: با استفاده از الگوی State، می‌توانید منطق مربوط به هر حالت را در کلاس‌های جداگانه پیاده‌سازی کنید. این باعث می‌شود کد خواناتر و قابل نگهداری‌تر باشد.
- افزایش قابلیت توسعه: اگر در آینده نیاز به اضافه کردن حالت‌های جدید یا تغییر رفتار فعلی باشد، الگوی State به شما این امکان را می‌دهد که به راحتی این تغییرات را اعمال کنید بدون این که بر سایر بخش‌های سیستم تاثیر بگذارد.

نحوه تحقق الگو

4.
- اصل SRP: این اصل مسئولیت واحد را نقض می کند. این الگو دو مشکل را حل می کند (اطمینان از اینکه یک کلاس فقط یک نمونه دارد و ارائه تنها یک مکان برای دسترسی به آن).
- اصل OCP: برای اینکه یک کلاس open باشد، باید امکان ارث بردن از آن وجود داشته باشد. وراثت یک رابطه "is-a" است. اگر از یک کلاس singleton به ارث می برید، نمونه هایی از کلاس فرزند نیز به دلیل رابطه "is-a" نمونه هایی از کلاس والد هستند، به این معنی که می توانید ناگهان چندین نمونه از کلاس singleton داشته باشید. اگر کلاس singleton از وراثت جلوگیری کند، دیگر open نیست. اگر یک کلاس singleton اجازه وراثت را بدهد، و برای گسترش open باشد، دیگر نمی تواند الگوی singleton را اجرا کند.
- اصل LSP: خود الگوی Singleton ذاتاً اصل جایگزینی Liskov را نقض نمی کند. با این حال، پیاده سازی الگوی Singleton گاهی اوقات می تواند منجر به مسائلی شود که ممکن است به طور غیرمستقیم با LSP در تضاد باشد، اگر با دقت طراحی نشود (مانند مورد قبلی).
- اصل ISP: الگوی Singleton خود ذاتاً اصل جداسازی رابط را نقض نمی کند (اگر رابط طراحی ضعیفی داشته باشد، ممکن است نقض شود). بنابراین می‌توانیم یک پیاده‌سازی اینترفیس Singleton داشته باشیم که تنها دارای یک تابع به نام getInstance در کنار برخی از اینترفیس‌های دیگر است که سعی در پیاده‌سازی برخی ویژگی‌های دلخواه دارند.
- اصل DIP: لزوماً اصل وارونگی وابستگی را نقض نمی کند، اما مانند مورد آخر، اگر طراحی ضعیفی داشته باشد، می تواند نقض شود. در واقع الگوی طراحی Singleton هیچ پیچیدگی و هیچ تلاقی با نحوه ارتباط کلاس های پیاده سازی شده با کلاس های دیگر ندارد.

5.
- کد تمیز: کدی که خوانا، قابل فهم، ساده، و به راحتی قابل نگهداری و توسعه باشد.
- بدهی فنی: مشکلات و نقص‌های کد که به دلیل تصمیمات سریع یا نادرست فنی ایجاد می‌شوند و نیاز به بازبینی و اصلاح دارند.
- بوی بد: نشانه‌هایی در کد که حاکی از مشکلات طراحی یا کیفیت پایین کد است و نیاز به اصلاح یا بهبود دارد.

6.

طبق دسته‌بندی وب‌سایت Refactoring.Guru، بوهای بد کد به پنج دسته تقسیم می‌شوند:

- بوهای بد در کلاس‌ها (Bloaters): این دسته شامل مشکلاتی است که ناشی از بزرگ شدن بیش از حد عناصر کد مانند کلاس‌ها و توابع می‌شوند. به عنوان مثال، کلاس‌های خیلی بزرگ (Large Class) یا توابع خیلی طولانی (Long Method) که به دلیل انجام کارهای بیش از حد پیچیده، مدیریت و درک کد را دشوار می‌کنند.
- بوهای بد در ساختارهای شرطی (Object-Orientation Abusers): این دسته شامل مشکلاتی است که به دلیل سوءاستفاده یا نادیده گرفتن اصول شی‌گرایی رخ می‌دهند. به عنوان مثال، پلی‌مورفیسم جایگزین شرط‌ها (Replace Conditional with Polymorphism) که به جای استفاده از چندریختی، از شرط‌های پیچیده استفاده می‌شود.
- بوهای بد در رابطه بین کلاس‌ها (Change Preventers): این دسته شامل مشکلاتی است که تغییرات در یک بخش از کد را به دلیل وابستگی زیاد بین کلاس‌ها دشوار می‌کنند. به عنوان مثال، وابستگی‌های پیچیده (Inappropriate Intimacy) که در آن کلاس‌ها بیش از حد به یکدیگر وابسته هستند.
- بوهای بد در کتابخانه‌ها و پکیج ها (Dispensables): این دسته شامل کدهایی است که غیرضروری هستند و می‌توان آنها را بدون تاثیر منفی حذف کرد. به عنوان مثال، کدهای مرده (Dead Code) که در پروژه استفاده نمی‌شوند یا کلاس‌های داده‌های بی‌خاصیت (Data Class) که فقط داده‌ها را نگهداری می‌کنند و هیچ رفتار مرتبطی ندارند.
- بوهای بد در معماری و طراحی کلی (Couplers): این دسته شامل مشکلاتی است که به دلیل طراحی ضعیف در ارتباطات بین ماژول‌ها یا کلاس‌ها به وجود می‌آیند. به عنوان مثال، وابستگی‌های متقابل (Feature Envy) که در آن یک کلاس بیش از حد به داده‌های کلاس دیگری وابسته است.

7.
بوی بد Lazy Class (کلاس تنبل) در دسته‌ی Dispensables قرار می‌گیرد. این دسته شامل کدهایی است که غیرضروری یا زائد هستند و می‌توان آن‌ها را بدون تأثیر منفی حذف کرد.

برای برطرف کردن بوی بد Lazy Class، می‌توان از این بازآرایی‌ها (Refactorings) استفاده کرد:

- Inline Class: در صورتی که یک کلاس وظایف محدودی دارد و تنها نقش یک واسطه را بازی می‌کند، می‌توانید آن را با درون‌سازی در کلاس دیگری که استفاده اصلی از آن می‌شود، ادغام کنید.
- Collapse Hierarchy: اگر کلاس موردنظر بخشی از یک سلسله مراتب است که عملکرد خاصی ندارد، می‌توان آن را با کلاس والد یا فرزند ترکیب کرده و سلسله مراتب را ساده‌سازی کرد.

مواقعی که باید نادیده گرفته شود:
-   در حال توسعه: اگر کلاس هنوز در حال توسعه است و قرار است در آینده عملکرد بیشتری به آن افزوده شود، ممکن است لازم باشد این بو را نادیده بگیرید.
-   ساختار کلی معماری: اگر کلاس به دلیل ساختار معماری خاصی وجود دارد و حتی اگر فعلاً وظایف محدودی دارد، ممکن است برای جلوگیری از پیچیدگی‌های آینده نادیده گرفته شود.
-   پیش‌بینی برای گسترش آینده: اگر پیش‌بینی می‌شود که کلاس به زودی نقش مهم‌تری در سیستم ایفا کند، می‌توان موقتاً آن را حفظ کرد.

8.
- Large Class: `Main` class
- Long Method: Method `loopOnGUI` in class `Main`
- Dead code: In method `generateInfoForXML` in class `Main`
- Speculative Generality: Variable `phase2` in method `main` in class `Main`
- Duplicate Code: Methods `setDataByNode` in classes `ClassConstructor` and `ClassMethod` have duplicate codes
- Switch Statements: Complex switch operator in method `generatePhase2` in class `Phase2CodeFileManipulator`
- Inappropriate Intimacy: Method `loopOnGUI` of class `Main` is using internal class `RealFunction` of class `MethodOverloader`
- Data Class: Class `DependencyEdge`
- Message Chains: In class `ClassMethod` line 88
- Feature Envy: Class `GUIClass` uses fields of class `Main`

9.
پلاگین `formatter-maven-plugin` یک پلاگین برای ابزار Maven است که به منظور فرمت و قالب‌بندی کدهای جاوا استفاده می‌شود. این پلاگین به صورت خودکار کدهای منبع را مطابق با قواعد و استانداردهای مشخص‌شده قالب‌بندی می‌کند.

وظایف و قابلیت‌ها:
- قالب‌بندی خودکار کد: این پلاگین می‌تواند کدهای جاوا را بر اساس تنظیمات مشخص شده (مانند فرمت‌بندی برای فاصله‌ها، تورفتگی‌ها، خطوط خالی و غیره) به صورت خودکار قالب‌بندی کند.
- یکپارچگی فرمت کد: با استفاده از این پلاگین، تمام کدهای پروژه به طور یکسان قالب‌بندی می‌شوند، که باعث می‌شود تیم توسعه بتواند از یک سبک کدنویسی واحد پیروی کند.
- قابلیت اجرا به صورت خودکار: این پلاگین می‌تواند به عنوان بخشی از فرآیند ساخت (build process) اجرا شود و اطمینان حاصل کند که کدها قبل از کامپایل یا انتشار، مطابق با استانداردهای مشخص‌شده قالب‌بندی شده‌اند.

چرا می‌تواند کمک‌کننده باشد؟
- افزایش خوانایی و نگهداری کد: قالب‌بندی منظم کد باعث می‌شود که کدها خواناتر و قابل‌فهم‌تر باشند، که این موضوع نگهداری و توسعه‌ی آن‌ها را ساده‌تر می‌کند.
- کاهش تضادها در کنترل نسخه: وقتی کدها به صورت یکپارچه قالب‌بندی شوند، احتمال بروز تضادها (conflicts) در سیستم‌های کنترل نسخه (مانند Git) کاهش می‌یابد.
- حفظ یکنواختی کد در تیم‌های بزرگ: در پروژه‌های با تیم‌های بزرگ، استفاده از یک قالب‌بندی مشترک به جلوگیری از اختلافات در سبک کدنویسی کمک می‌کند.

رابطه با بازآرایی کد (Refactoring):
بازآرایی کد شامل تغییر ساختار کد بدون تغییر رفتار آن است. در این فرآیند، بهبود ساختار داخلی کد و بهبود خوانایی و سادگی آن هدف اصلی است.

- کمک به شناسایی نیاز به بازآرایی: زمانی که کد به خوبی قالب‌بندی شده و خواناست، شناسایی نیاز به بازآرایی کدهای پیچیده، تکراری یا بدساختار ساده‌تر می‌شود.
- پیاده‌سازی بازآرایی‌ها: پس از بازآرایی کد، قالب‌بندی مناسب با استفاده از این پلاگین می‌تواند تضمین کند که کد بازآرایی‌شده همچنان خوانا و منظم باقی بماند.

بنابراین، `formatter-maven-plugin` به عنوان یک ابزار مکمل می‌تواند به فرآیند بازآرایی کد کمک کند تا کد بازآرایی‌شده نه تنها بهینه‌تر، بلکه از نظر ظاهری نیز منظم‌تر و حرفه‌ای‌تر باشد.
